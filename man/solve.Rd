% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/RaspSolved.R, R/generics.R
\docType{methods}
\name{solve,RaspUnsolOrSol,missing-method}
\alias{solve}
\alias{solve,RaspUnsolOrSol,GurobiOpts-method}
\alias{solve,RaspUnsolOrSol,logical-method}
\alias{solve,RaspUnsolOrSol,matrix-method}
\alias{solve,RaspUnsolOrSol,missing-method}
\alias{solve,RaspUnsolOrSol,numeric-method}
\title{Solve RASP object}
\usage{
\S4method{solve}{RaspUnsolOrSol,missing}(a, b, ..., verbose = FALSE)

\S4method{solve}{RaspUnsolOrSol,GurobiOpts}(a, b, verbose = FALSE)

\S4method{solve}{RaspUnsolOrSol,matrix}(a, b, verbose = FALSE)

\S4method{solve}{RaspUnsolOrSol,numeric}(a, b, verbose = FALSE)

\S4method{solve}{RaspUnsolOrSol,logical}(a, b, verbose = FALSE)

solve(a, b, ...)
}
\arguments{
\item{a}{\code{RaspUnsolved} or \code{RaspSolved} object.}

\item{b}{\code{missing} to generate solutions using Gurobi. Prioritisations can be specified using  \code{logical}, \code{numeric}, or \code{matrix} objects. This may be useful for evaluating the performance of solutions obtained using other software.}

\item{...}{not used.}

\item{verbose}{\code{logical} should messages be printed during creation of the initial model matrix?.}
}
\value{
\code{RaspSolved} object
}
\description{
This function uses Gurobi to find prioritisations using the input parameter and data stored in a \code{RaspUsolved} object,
and returns a \code{RaspSolved} object with outputs in it.
}
\section{Methods (by class)}{
\itemize{
\item \code{a = RaspUnsolOrSol,b = missing}: 

\item \code{a = RaspUnsolOrSol,b = GurobiOpts}: 

\item \code{a = RaspUnsolOrSol,b = matrix}: 

\item \code{a = RaspUnsolOrSol,b = numeric}: 

\item \code{a = RaspUnsolOrSol,b = logical}: 
}}
\note{
This function is used to solve a \code{RaspUnsolved} object that has all of its inputs generated. The rasp function (without lower case 'r') provides a more general interface for generating inputs and outputs.
}
\examples{
# load RaspUnsolved object
data(sim_ru)
\dontrun{
# solve it using Gurobi
sim_rs <- solve(sim_ru)
}
# evaluate manually specified solution using planning unit indices
sim_rs2 <- solve(sim_ru, 1:10)
# evaluate manually specifed solution using binary selections
sim_rs3 <- solve(sim_ru, c(rep(TRUE,10), rep(FALSE, 215)))
#  evaluate multiple manually specified solutions
sim_rs4 <- solve(sim_ru, matrix(sample(c(0,1), size=1125, replace=TRUE), ncol=225, nrow=5))
}
\seealso{
\code{\link{RaspUnsolved}}, \code{\link{RaspSolved}}.
}

